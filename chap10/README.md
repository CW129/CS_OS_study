# CS_OS_study
“혼자하는 컴퓨터구조+운영채제” 책을 통해 학습한 내용을 정리하여 스터디 그룹 내에 공유하기위한 레파지토리입니다


## Chapter 10

## ch10 프로세스와 스레드

### 10-1 프로세스 개요
실행 중인 프로그램 -> 프로새스
보조기억 장치에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 프로그램은 프로세스가 됩니다.

- 프로세스를 확인
윈도우 :  작업관리자를 통해 프로세스 점유율 및 사용량을 알 수 있습니다.
다른 운영체제 : ps -ef 명령어를 통해 확인


포그라운드 프로세스(foreground process 다중 프로그래밍, 전경, 최전의) 
-> 사용자가 볼 수 있는 공간에서 실행되느 프로세스

백그라운드 프로세스(background process 배경, 배후의 )
-> 사용자가 볼 수 없는 공간에서 실행되는 프로세스

백그라운드 프로세스에는 두가지 종류 존재, 하나는 상호작용 할 수 있는 프로세스, 상호작용하지 않고 백그라운드에서 실행되는 프로세스가 존재하는데, 유닉스계열은 데몬(daemon), 윈도우체제는 서비스라고 부르고 있습니다.


- 프로세스 제어 블록(PCB Process Control Block)
모든 프로세스를 실행하기 위해 CPU가 필요합니다.
타이머 인터럽트를 통하여 프로세스를 스위칭 합니다.

프로세스의 상태, 프로세스 카운터, 레지스터, 스택 포인터, 스택, 프로세스 번호, 프로세스 우선순위, 프로세스가 사용하는 자원이 포함됩니다.

// 프로세스 ID(Process ID, PID) : 프로세스의 고유한 번호
(kill -9 [pid] 프로세스 강제종료)

// 레지스터 값 : 프로세스가 실행되는 동안 변경되는 값, 프로세스가 실행하여 사용했던 프로그램 카운터를 비롯한 레지스터 값을 담아둡니다.

// 프로세스 상태 : 프로세스가 어떤 상태인지 PCB에 기록되어야 합니다.

// CPU 스케줄링 정보 : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등이 포함됩니다. 프로세스가 언제, 어떤 순서로 CPU를 할당 받을지에 대한 정보도 PCB에 기록됩니다.

// 메모리 관리 정보 : 프로세스가 사용하는 메모리 주소 범위

// 사용한 파일과 입출력장치목록 : 프로세스가 사용하는 입출력 장치에 대한 포인터 포함

- 문맥 교환
문맥 : 프로세스 수행을 재개 하기 위한 기억해야할 중간 정보

예상치 못한 상황이 발생하여 인터럽트가 발생하면 운영체제는 해당 프로세스에 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB 문맥을 백업합니다.

- 프로세스의 매모리 영역
프로세스는 사용자 영억에 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉘어 저장합니다.

// 코드 영역 : 기계어로 이루어진 명령어가 저장된다. 읽기 전용 영역
// 데이터 영역 : 전역 변수와 정적 변수가 저장
// 힙 영역 : 프로그래머가 직접 할당 할 수 있는 영역입니다. 메모리 공간을 반환하지 않는다면 메모리 내에 계속 남아 메모리 낭비를 초래합니다. 이러한 문제를 메모리 누수가 발생한다고 말할수 있습니ㅏㄷ.

// 스택영역 : 함수의 호출과 관계되는 지역 변수와 매개변수가 저장, 함수의 호출이 끝나면 스택 영역에서 제거됩니다.

![10-1확인문제](/cs_study_ch10/10-1%ED%99%95%EC%9D%B8%EB%AC%B8%EC%A0%9C.png)




### 10-2 프로세스 상태와 계층 구조
- 프로세스 상태
프로세스 상태는 프로세스가 현재 어떤 작업을 하고 있는지 나타냅니다.

생성 -> 프로세스를 생성 중인 상태, 메모리에 적재되어 PCB를 할당
준비 -> 메모리에 적재되어 CPU를 기다리는 상태, 준비 상태인 프로세스가 실행 상태로 전환 디는 것을 디스패치라고 합니다.
실행 -> CPU에 점유하고 명령 및 실행되어야할 항목들을 실행하는 상태.
대기 -> 입출력을 기다리는 상태, 완료되면 준비상태로 전화
종료 -> 프로세스가 종료된 상태, 운영체제는 PCB,메모리 할당을 해제.


- 프로세스 계층 구조
프로세스는 계층 구조로 관리됩니다.
부모는 자식을 생성 / 자식은 부모 자원 공유
각각  별개의 프로세스이므로 PCB를 가집니다.

- 프로세스 생성 기법
부모 프로세스는 fork, exec 통해 자식 프로세스 생성
다만 생성되는 자식 프로세스는 새로운 PID를 부여받지만 PPID라는 부모의 값을 가지고 구분됩니다.

fork : 부모 프로세스 복사본을 자식으로 생성
exec : 자식 프로세스의 메모리 공간을 다른 프로그램으로 덮어씁니다.


### fork 예시
```
#include <stdio.h>
#include <unistd.h>

int main() {
    int x;
    x = 0;
    
    fork();
    
    x = 1;
    printf("PID : %ld,  x : %d\n",getpid(), x);
    
    return 0;
}
```

### fork 함수가 실행 된 직후 자식 프로세스가 부모 프로세스와 동일한 주소 공간을 복사하여 가지게 됩니다.

### 부모와 자식 프로세스는 동일한 코드 (x=1,printf())를 각자 메모리상에서 실행합니다.

![fork 설명](/cs_study_ch10/fork%EB%AA%85%EB%A0%B9.jpeg)

## 10-3 스레드

### 스레드 
-  스레드는 실행의 단위, 스레드란 프로세스 구성하는 행의 흐름 단위 입니다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다. 스레드를 이용하면 하나의 프로세스에서 여러 부분을 동시에 실행 가능합니다.

### 멀티프로세스 / 멀티스레드
- 여러 프로세스를 동시에 실행하는 것을 멀티프로세싱, 여러 스레드로 프로세스를 동시에 실행하는 것을 멀티스레드라고 합니다.
프로세스 끼리는 자원을 공유할 수 없지만 스레드는 프로세스의 자원을 공유 할 수 있습니다.

![멀티스레드,멀티프로세스](/cs_study_ch10/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4.png)
