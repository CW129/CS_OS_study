# 3. 명령어

개발자가 작성한 코드는 컴퓨터의 CPU에 저장되어진 명령어 집합을 통해 이루어진다

<aside>
💡 저장장소에 작성되어진 소스코드가 CPU로 가기까지의 과정<br>
개발자에의해 작성되어진 소스코드는 **저장소(하드디스크)와 같은 보조기억장치에 존재**하고 있다가 실행 시 **컴퓨터가 이해할 수 있는 언어로 변환**되어 **Memory에 저장**되어집니다 이후 CPU 연산에 따라 필요한 명령어나 데이터를 메모리에서 가져와 실행 시키게 됩니다

</aside>

## 저급 언어와 고급 언어

개발자가 작성한 코드는 컴퓨터가 바로 이해할 수 없기 때문에 저급 언어인 어셈블리어, 기계어 순으로 변경되어 컴퓨터가 활용할 수 있는 데이터의 형태로 변경되어지게 됩니다

![https://user-images.githubusercontent.com/65060314/230827713-ecca2f28-5893-4981-9619-4e7e58859784.png](https://user-images.githubusercontent.com/65060314/230827713-ecca2f28-5893-4981-9619-4e7e58859784.png)

### 저급 언어

저급 언어는 고급언어를 통해 작성되어진 코드를 컴퓨터가 이해할 수 있는 코드로 변환하여 실행하게 끔 하는 코드입니다 

[ex] 기계어, 어셈블리어

<aside>
💡 어셈블리어는 누가 많이 사용하는가?<br>
하드웨어와밀접하게맞닿아있는프로그램을개발하는임베디드개발자, 게임개발자, 정보보안
분야등의 개발자는아래와 같이 어셈블리어를많이이용합니다.

</aside>

### 고급 언어

우리가 작성한 언어는 고급 언어입니다 해당언어는 컴퓨터가 이해하기 쉬운 언어라기 보다는 개발자(사람)이 이해하기 쉬운 언어입니다

[ex] Go, Java, Python, Javascript, 등등

## 고급 언어의 종류

### 컴파일 언어

작성된 소스코드 전체가 컴파일러를 통해 저급 언어로 변환되는 언어를 컴파일 언어라 칭합니다 또한 이렇게 변환된 저급언어를 목적 코드라고 칭합니다 

소스코드 전체를 변환함에 따라 컴파일언어는 구문 오류가 생길 경우 전체에 대해서 에러 처리를 하게됩니다

![https://user-images.githubusercontent.com/65060314/230828849-5f7a6a64-888c-46d3-8cf2-438c73bb83ff.png](https://user-images.githubusercontent.com/65060314/230828849-5f7a6a64-888c-46d3-8cf2-438c73bb83ff.png)

### 인터프리터 언어

인터프리터 언어는 작성된 코드를 한줄 씩 저급언어로 변환하는 언어를 의미합니다 인터프리터를 통해 한줄의 코드를 읽어 낸 뒤 해당 구문을 기계어로 번역하여 목적 코드를 실행 시키게됩니다

한줄 씩 변환한다는 점을 통해 인터프리터 언어는 에러가 생기는 N번째 코드 이전의 데이터는 무사히 실행 시킬 수 있다는 장점이 있습니다

<aside>
💡 인터프리터와 컴파일의 경계는 뚜렷한가?<br>
근래에 들어서 두 가지 고급언어의 경계는 뚜렷하지 않습니다 Python의 경우 실행된 함수나 모듈에 대해서 C-python이라는 모듈을 통해 내부 명령어를 컴파일하여 캐시파일로 등록하여 실행 시킬 수 있는 구조로 되어 있으며 javascript 또한 V8엔진을 통해 파이썬과 같이 캐시파일로 등록하여 실행 시킵니다

</aside>

참고 자료(****V8 에서 Javascript 코드를 실행하는 방법 정리해보기****) : [https://pks2974.medium.com/v8-에서-javascript-코드를-실행하는-방법-정리해보기-25837f61f551](https://pks2974.medium.com/v8-%EC%97%90%EC%84%9C-javascript-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EC%A0%95%EB%A6%AC%ED%95%B4%EB%B3%B4%EA%B8%B0-25837f61f551)

## 목적파일과 실행파일

### 목적파일

목적코드(컴파일러나 인터프리터를 통해 컴퓨터가 이해 할 수 있도록 변환된 코드)로 이루어진 파일을 목적 파일

### 실행파일

실행 코드로 이루어진 파일을 실행 파일이라고 칭함

<aside>
💡 실행 코드 란?<br>
목적 코드가 실행코드가 되기위해서는 링킹이라는 작업을 거쳐야합니다 
링킹이란 작업은 목적 코드로 변환되어진 코드를 실제 동작하는 명령어들과 매핑시켜주는 작업을 말합니다

</aside>

## 명령어의 구조

명령어는 연산코드와 오퍼랜드로 이루어져있습니다

### 연산코드와 오퍼랜드

**오퍼랜드**

오퍼랜드는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 존재하는 위치를 의미합니다
실제로 오퍼랜드는 데이터를 직접 담기보다는 데이터가 존재하는 위치를 가르키는 경우가 많아 주소 필드라고 불려집니다

<aside>
💡 데이터가 담겨지는 경우<br>
대입 연산자와 같이 특정한 변수에 값을 할당 해야할 경우 데이터를 직접적으로 담게됩니다

</aside>

또한 오퍼랜드의 갯수에 따라 명령어의 이름이 달라지게 되는데 자세한 내용은 아래의 표와 같습니다

| 명령어 종류 | 내용 | 예시 |
| --- | --- | --- |
| 0 - 주소 명령어 | 오퍼랜드가 없는 명령어 | 단일 명령어 구조 |
| 1 - 주소 명령어 | 오퍼랜드가 하나인 명령어 | 단일 연산자  [ex] ‘a = 1’ |
| 2 - 주소 명령어 | 오퍼랜드가 두개인 명령어 | 이항 연산자 [ex]  ‘a + b’ |
| 3 - 주소 명령어 | 오퍼랜드가 3개인 명령어 | 삼항 연산자 [ex] ‘a > b ? a : b’ |

**연산코드**

연산 코드는 명령어가 수행할 연산을 의미하며 크게 4가지의 유형으로 나눌 수 있으며 자세한 내용은 아래와 같습니다

| 연산 유형 | 내용 | 예제 |
| --- | --- | --- |
| 데이터 전송 | 데이터와 관련된 연산에 대한 내용을 다룸 | MOVE,STORE,LOAD,PUSH,POP |
| 산술/논리연산 | 숫자나 비트열 연산을 위한 명령어 유형 | ADD,AND,OR,COMPARE 등 |
| 제어 흐름 변경 | 현재 진행 죽인 job에서 다른 job으로 변경하거나 프로그램 실행을 제어해야할 경우 사용하는 명령어 | JUMP,HALT,RETURN 등 |
| 입출력 제어 | 입출력 장치를 관리하고 제어하기 위한 명령어 | READ, WRITE, START IO, TEST IO |

## 주소지정 방식

주소지정 방식을 오퍼랜드가 사용하는 이유는 연산코드의 길이와 연관이 있습니다 

[예제] 1 - 주소 명령어인 명령어 하나의 길이가 M이고 연산 코드의 길이는 N 일 때 사용가능 한 오퍼랜드 크기는 ‘M-N’ 이다

![https://user-images.githubusercontent.com/65060314/230835295-74e8babb-c441-4b08-958f-70c2c62b47b5.png](https://user-images.githubusercontent.com/65060314/230835295-74e8babb-c441-4b08-958f-70c2c62b47b5.png)

오퍼랜드 값이 줄어 듬에 따라 많은 양의 데이터를 담을 수 없음으로 오퍼랜드에는 메모리 주소를 전달 받아 데이터를 전달 받도록 하는 구조를 **주소지정방식**이라고 합니다

주소 지정방식의 종류는 5가지가 있으며 아래의 같습니다

### 즉시 주소 지정 방식

사용하고자 하는 데이터를 직접 오퍼랜드에 넣는 방식 → 넣을 수 있는 데이터가 한정적

![https://user-images.githubusercontent.com/65060314/230836112-de9d5765-066f-4b3f-a79e-cd38a69c75ee.png](https://user-images.githubusercontent.com/65060314/230836112-de9d5765-066f-4b3f-a79e-cd38a69c75ee.png)

### 직접 주소 지정 방식

사용하고자 하는 데이터의 메모리 주소를 넣는 방식 → 즉시 주소 지정 방식 보다는 많은 데이터를 담을 수 있지만 한계가 있음

![https://user-images.githubusercontent.com/65060314/230836374-e1089a41-84bb-4187-80e4-40dc1be1e24a.png](https://user-images.githubusercontent.com/65060314/230836374-e1089a41-84bb-4187-80e4-40dc1be1e24a.png)

### 간접 주소 지정 방식

메모리에서 주소를 가져오지만 이 주소는 실제 데이터를 가지고 있는 메모리 주소로 직접 주소지정 방식에서 한번 더 메모리 주소를 참조하는 방식 → 두번의 메모리 참조로 인해 느림

![https://user-images.githubusercontent.com/65060314/230836577-167b7558-1148-4648-a1b4-d119bc47901e.png](https://user-images.githubusercontent.com/65060314/230836577-167b7558-1148-4648-a1b4-d119bc47901e.png)

### 레지스터 주소 지정 방식

직접 주소 지정 방식과 비슷하나 메모리가 아닌 CPU 레지스터의 주소를 참조하여 사용 → 표현할 수 있는 크기가 레지스터의 크기로 제한됨

![https://user-images.githubusercontent.com/65060314/230836809-729e99df-4d0a-45c4-b739-03ec91e7bc63.png](https://user-images.githubusercontent.com/65060314/230836809-729e99df-4d0a-45c4-b739-03ec91e7bc63.png)

### 레지스터 간접 주소 지정 방식

연산에 사용할 데이터를 메모리에 저장하되  그 주소는 레지스터에 저장하고 연산시 불러와서 사용 → 간접주소 지정 방식보다는 빠름

![https://user-images.githubusercontent.com/65060314/230837871-cde5a681-1ec4-45b4-b58d-485bdfc1452d.png](https://user-images.githubusercontent.com/65060314/230837871-cde5a681-1ec4-45b4-b58d-485bdfc1452d.png)

## 스택과 큐

### 스택

한쪽 끝이 막혀있는 통과 같은 저장공간이며  LIFO(Last In First Out)로 먼저 들어온 데이터가 가장 나중에 나가는 형태의 저장공간입니다

### 큐

양쪽이 뚫려 있는 저장공간  FIFO (First In First Out)로 먼저 들어온 데이터가 가장 먼저 가나는 형태의 저장 공간